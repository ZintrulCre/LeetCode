### 丑数

丑数是质因数只有 2, 3, 5 的正整数。丑数类的题目用暴力法一般都会 TLE，可以用 DP 来将时间复杂度优化到 O(m * n)，其中 m 是质因数的个数，n 是要找的第n个丑数。

#### [263 丑数](https://leetcode-cn.com/problems/ugly-number/)

判断一个数 num 是否是丑数。

通用的方法是用 DP 自底向上求出大于等于 num 的第一个数来判断 num 是否是丑数。但这道题已经给出了数 num，直接通过模运算就能得到结果了。

```c++
class Solution {
public:
    bool isUgly(int num) {
        if (num < 1)
            return false;
        while (num % 2 == 0)
            num /= 2;
        while (num % 3 == 0)
            num /= 3;
        while (num % 5 == 0)
            num /= 5;
        return num == 1;
    }
};
```

#### [264 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/comments/)

求第 n 个丑数。

用一个数组 ugly 来保存前 m 个丑数，用三个质因数 2，3，5 乘以其当前系数对应的丑数，得到新的丑数，最小的一个就是第 m + 1 个丑数。

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> ugly(n, 1);
        int base_2 = 0, base_3 = 0, base_5 = 0;
        int m = INT_MAX;
        for (int i = 1; i < n; ++i) {
            ugly[i] = min({2 * ugly[base_2], 3 * ugly[base_3], 5 * ugly[base_5]});
            if (2 * ugly[base_2] == ugly[i])
                ++base_2;
            if (3 * ugly[base_3] == ugly[i])
                ++base_3;
            if (5 * ugly[base_5] == ugly[i])
                ++base_5;
            cout << ugly[i] << endl;
        }
        return ugly[n - 1];
    }
};
```

#### [313 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/submissions/)

给定质因数数组 primes，求第 n 个丑数。

跟上一题完全相同，只是把原有的三个质因数 2，3，5 换成了一个数组。

```c++
class Solution {
public:
    int nthSuperUglyNumber(int N, vector<int>& primes) {
        int n = primes.size(), m = INT_MAX;;
        vector<int> ugly(N, 1), base(n, 0);
        for (int i = 1; i < N; ++i) {
            m = INT_MAX;
            for (int j = 0; j < n; ++j)
                m = min(m, primes[j] * ugly[base[j]]);
            ugly[i] = m;
            for (int j = 0; j < n; ++j)
                if (primes[j] * ugly[base[j]] == m)
                    ++base[j];
        }
        return ugly[N - 1];
    }
};
```